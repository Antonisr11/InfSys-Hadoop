/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package app;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import org.apache.avro.file.DataFileWriter;
import org.apache.avro.io.DatumWriter;
import org.apache.avro.specific.SpecificDatumWriter;
import org.apache.avro.file.DataFileReader;
import org.apache.avro.io.DatumReader;
import org.apache.avro.specific.SpecificDatumReader;

@org.apache.avro.specific.AvroGenerated
public class avro extends org.apache.avro.specific.SpecificRecordBase
		implements org.apache.avro.specific.SpecificRecord {
	private static final long serialVersionUID = 3207090768004672889L;
	public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse(
			"{\"type\":\"record\",\"name\":\"avro\",\"namespace\":\"app\",\"fields\":[{\"name\":\"date\",\"type\":\"string\"},{\"name\":\"country\",\"type\":\"string\"},{\"name\":\"city\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"double\"}]}");

	public static org.apache.avro.Schema getClassSchema() {
		return SCHEMA$;
	}

	private static SpecificData MODEL$ = new SpecificData();

	private static final BinaryMessageEncoder<avro> ENCODER = new BinaryMessageEncoder<avro>(MODEL$, SCHEMA$);

	private static final BinaryMessageDecoder<avro> DECODER = new BinaryMessageDecoder<avro>(MODEL$, SCHEMA$);

	/**
	 * Return the BinaryMessageEncoder instance used by this class.
	 * 
	 * @return the message encoder used by this class
	 */
	public static BinaryMessageEncoder<avro> getEncoder() {
		return ENCODER;
	}

	/**
	 * Return the BinaryMessageDecoder instance used by this class.
	 * 
	 * @return the message decoder used by this class
	 */
	public static BinaryMessageDecoder<avro> getDecoder() {
		return DECODER;
	}

	/**
	 * Create a new BinaryMessageDecoder instance for this class that uses the
	 * specified {@link SchemaStore}.
	 * 
	 * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
	 * @return a BinaryMessageDecoder instance for this class backed by the given
	 *         SchemaStore
	 */
	public static BinaryMessageDecoder<avro> createDecoder(SchemaStore resolver) {
		return new BinaryMessageDecoder<avro>(MODEL$, SCHEMA$, resolver);
	}

	/**
	 * Serializes this avro to a ByteBuffer.
	 * 
	 * @return a buffer holding the serialized data for this instance
	 * @throws java.io.IOException if this instance could not be serialized
	 */
	public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
		return ENCODER.encode(this);
	}

	/**
	 * Deserializes a avro from a ByteBuffer.
	 * 
	 * @param b a byte buffer holding serialized data for an instance of this class
	 * @return a avro instance decoded from the given buffer
	 * @throws java.io.IOException if the given bytes could not be deserialized into
	 *                             an instance of this class
	 */
	public static avro fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException {
		return DECODER.decode(b);
	}

	private java.lang.CharSequence date;
	private java.lang.CharSequence country;
	private java.lang.CharSequence city;
	private double value;

	/**
	 * Default constructor. Note that this does not initialize fields to their
	 * default values from the schema. If that is desired then one should use
	 * <code>newBuilder()</code>.
	 */
	public avro() {
	}

	/**
	 * All-args constructor.
	 * 
	 * @param date    The new value for date
	 * @param country The new value for country
	 * @param city    The new value for city
	 * @param value   The new value for value
	 */
	public avro(java.lang.CharSequence date, java.lang.CharSequence country, java.lang.CharSequence city,
			java.lang.Double value) {
		this.date = date;
		this.country = country;
		this.city = city;
		this.value = value;
	}

	public org.apache.avro.specific.SpecificData getSpecificData() {
		return MODEL$;
	}

	public org.apache.avro.Schema getSchema() {
		return SCHEMA$;
	}

	// Used by DatumWriter. Applications should not call.
	public java.lang.Object get(int field$) {
		switch (field$) {
		case 0:
			return date;
		case 1:
			return country;
		case 2:
			return city;
		case 3:
			return value;
		default:
			throw new IndexOutOfBoundsException("Invalid index: " + field$);
		}
	}

	// Used by DatumReader. Applications should not call.
	@SuppressWarnings(value = "unchecked")
	public void put(int field$, java.lang.Object value$) {
		switch (field$) {
		case 0:
			date = (java.lang.CharSequence) value$;
			break;
		case 1:
			country = (java.lang.CharSequence) value$;
			break;
		case 2:
			city = (java.lang.CharSequence) value$;
			break;
		case 3:
			value = (java.lang.Double) value$;
			break;
		default:
			throw new IndexOutOfBoundsException("Invalid index: " + field$);
		}
	}

	/**
	 * Gets the value of the 'date' field.
	 * 
	 * @return The value of the 'date' field.
	 */
	public java.lang.CharSequence getDate() {
		return date;
	}

	/**
	 * Sets the value of the 'date' field.
	 * 
	 * @param value the value to set.
	 */
	public void setDate(java.lang.CharSequence value) {
		this.date = value;
	}

	/**
	 * Gets the value of the 'country' field.
	 * 
	 * @return The value of the 'country' field.
	 */
	public java.lang.CharSequence getCountry() {
		return country;
	}

	/**
	 * Sets the value of the 'country' field.
	 * 
	 * @param value the value to set.
	 */
	public void setCountry(java.lang.CharSequence value) {
		this.country = value;
	}

	/**
	 * Gets the value of the 'city' field.
	 * 
	 * @return The value of the 'city' field.
	 */
	public java.lang.CharSequence getCity() {
		return city;
	}

	/**
	 * Sets the value of the 'city' field.
	 * 
	 * @param value the value to set.
	 */
	public void setCity(java.lang.CharSequence value) {
		this.city = value;
	}

	/**
	 * Gets the value of the 'value' field.
	 * 
	 * @return The value of the 'value' field.
	 */
	public double getValue() {
		return value;
	}

	/**
	 * Sets the value of the 'value' field.
	 * 
	 * @param value the value to set.
	 */
	public void setValue(double value) {
		this.value = value;
	}

	/**
	 * Creates a new avro RecordBuilder.
	 * 
	 * @return A new avro RecordBuilder
	 */
	public static app.avro.Builder newBuilder() {
		return new app.avro.Builder();
	}

	/**
	 * Creates a new avro RecordBuilder by copying an existing Builder.
	 * 
	 * @param other The existing builder to copy.
	 * @return A new avro RecordBuilder
	 */
	public static app.avro.Builder newBuilder(app.avro.Builder other) {
		if (other == null) {
			return new app.avro.Builder();
		} else {
			return new app.avro.Builder(other);
		}
	}

	/**
	 * Creates a new avro RecordBuilder by copying an existing avro instance.
	 * 
	 * @param other The existing instance to copy.
	 * @return A new avro RecordBuilder
	 */
	public static app.avro.Builder newBuilder(app.avro other) {
		if (other == null) {
			return new app.avro.Builder();
		} else {
			return new app.avro.Builder(other);
		}
	}

	/**
	 * RecordBuilder for avro instances.
	 */
	@org.apache.avro.specific.AvroGenerated
	public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<avro>
			implements org.apache.avro.data.RecordBuilder<avro> {

		private java.lang.CharSequence date;
		private java.lang.CharSequence country;
		private java.lang.CharSequence city;
		private double value;

		/** Creates a new Builder */
		private Builder() {
			super(SCHEMA$);
		}

		/**
		 * Creates a Builder by copying an existing Builder.
		 * 
		 * @param other The existing Builder to copy.
		 */
		private Builder(app.avro.Builder other) {
			super(other);
			if (isValidValue(fields()[0], other.date)) {
				this.date = data().deepCopy(fields()[0].schema(), other.date);
				fieldSetFlags()[0] = other.fieldSetFlags()[0];
			}
			if (isValidValue(fields()[1], other.country)) {
				this.country = data().deepCopy(fields()[1].schema(), other.country);
				fieldSetFlags()[1] = other.fieldSetFlags()[1];
			}
			if (isValidValue(fields()[2], other.city)) {
				this.city = data().deepCopy(fields()[2].schema(), other.city);
				fieldSetFlags()[2] = other.fieldSetFlags()[2];
			}
			if (isValidValue(fields()[3], other.value)) {
				this.value = data().deepCopy(fields()[3].schema(), other.value);
				fieldSetFlags()[3] = other.fieldSetFlags()[3];
			}
		}

		/**
		 * Creates a Builder by copying an existing avro instance
		 * 
		 * @param other The existing instance to copy.
		 */
		private Builder(app.avro other) {
			super(SCHEMA$);
			if (isValidValue(fields()[0], other.date)) {
				this.date = data().deepCopy(fields()[0].schema(), other.date);
				fieldSetFlags()[0] = true;
			}
			if (isValidValue(fields()[1], other.country)) {
				this.country = data().deepCopy(fields()[1].schema(), other.country);
				fieldSetFlags()[1] = true;
			}
			if (isValidValue(fields()[2], other.city)) {
				this.city = data().deepCopy(fields()[2].schema(), other.city);
				fieldSetFlags()[2] = true;
			}
			if (isValidValue(fields()[3], other.value)) {
				this.value = data().deepCopy(fields()[3].schema(), other.value);
				fieldSetFlags()[3] = true;
			}
		}

		/**
		 * Gets the value of the 'date' field.
		 * 
		 * @return The value.
		 */
		public java.lang.CharSequence getDate() {
			return date;
		}

		/**
		 * Sets the value of the 'date' field.
		 * 
		 * @param value The value of 'date'.
		 * @return This builder.
		 */
		public app.avro.Builder setDate(java.lang.CharSequence value) {
			validate(fields()[0], value);
			this.date = value;
			fieldSetFlags()[0] = true;
			return this;
		}

		/**
		 * Checks whether the 'date' field has been set.
		 * 
		 * @return True if the 'date' field has been set, false otherwise.
		 */
		public boolean hasDate() {
			return fieldSetFlags()[0];
		}

		/**
		 * Clears the value of the 'date' field.
		 * 
		 * @return This builder.
		 */
		public app.avro.Builder clearDate() {
			date = null;
			fieldSetFlags()[0] = false;
			return this;
		}

		/**
		 * Gets the value of the 'country' field.
		 * 
		 * @return The value.
		 */
		public java.lang.CharSequence getCountry() {
			return country;
		}

		/**
		 * Sets the value of the 'country' field.
		 * 
		 * @param value The value of 'country'.
		 * @return This builder.
		 */
		public app.avro.Builder setCountry(java.lang.CharSequence value) {
			validate(fields()[1], value);
			this.country = value;
			fieldSetFlags()[1] = true;
			return this;
		}

		/**
		 * Checks whether the 'country' field has been set.
		 * 
		 * @return True if the 'country' field has been set, false otherwise.
		 */
		public boolean hasCountry() {
			return fieldSetFlags()[1];
		}

		/**
		 * Clears the value of the 'country' field.
		 * 
		 * @return This builder.
		 */
		public app.avro.Builder clearCountry() {
			country = null;
			fieldSetFlags()[1] = false;
			return this;
		}

		/**
		 * Gets the value of the 'city' field.
		 * 
		 * @return The value.
		 */
		public java.lang.CharSequence getCity() {
			return city;
		}

		/**
		 * Sets the value of the 'city' field.
		 * 
		 * @param value The value of 'city'.
		 * @return This builder.
		 */
		public app.avro.Builder setCity(java.lang.CharSequence value) {
			validate(fields()[2], value);
			this.city = value;
			fieldSetFlags()[2] = true;
			return this;
		}

		/**
		 * Checks whether the 'city' field has been set.
		 * 
		 * @return True if the 'city' field has been set, false otherwise.
		 */
		public boolean hasCity() {
			return fieldSetFlags()[2];
		}

		/**
		 * Clears the value of the 'city' field.
		 * 
		 * @return This builder.
		 */
		public app.avro.Builder clearCity() {
			city = null;
			fieldSetFlags()[2] = false;
			return this;
		}

		/**
		 * Gets the value of the 'value' field.
		 * 
		 * @return The value.
		 */
		public double getValue() {
			return value;
		}

		/**
		 * Sets the value of the 'value' field.
		 * 
		 * @param value The value of 'value'.
		 * @return This builder.
		 */
		public app.avro.Builder setValue(double value) {
			validate(fields()[3], value);
			this.value = value;
			fieldSetFlags()[3] = true;
			return this;
		}

		/**
		 * Checks whether the 'value' field has been set.
		 * 
		 * @return True if the 'value' field has been set, false otherwise.
		 */
		public boolean hasValue() {
			return fieldSetFlags()[3];
		}

		/**
		 * Clears the value of the 'value' field.
		 * 
		 * @return This builder.
		 */
		public app.avro.Builder clearValue() {
			fieldSetFlags()[3] = false;
			return this;
		}

		@Override
		@SuppressWarnings("unchecked")
		public avro build() {
			try {
				avro record = new avro();
				record.date = fieldSetFlags()[0] ? this.date : (java.lang.CharSequence) defaultValue(fields()[0]);
				record.country = fieldSetFlags()[1] ? this.country : (java.lang.CharSequence) defaultValue(fields()[1]);
				record.city = fieldSetFlags()[2] ? this.city : (java.lang.CharSequence) defaultValue(fields()[2]);
				record.value = fieldSetFlags()[3] ? this.value : (java.lang.Double) defaultValue(fields()[3]);
				return record;
			} catch (org.apache.avro.AvroMissingFieldException e) {
				throw e;
			} catch (java.lang.Exception e) {
				throw new org.apache.avro.AvroRuntimeException(e);
			}
		}
	}

	@SuppressWarnings("unchecked")
	private static final org.apache.avro.io.DatumWriter<avro> WRITER$ = (org.apache.avro.io.DatumWriter<avro>) MODEL$
			.createDatumWriter(SCHEMA$);

	@Override
	public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {
		WRITER$.write(this, SpecificData.getEncoder(out));
	}

	@SuppressWarnings("unchecked")
	private static final org.apache.avro.io.DatumReader<avro> READER$ = (org.apache.avro.io.DatumReader<avro>) MODEL$
			.createDatumReader(SCHEMA$);

	@Override
	public void readExternal(java.io.ObjectInput in) throws java.io.IOException {
		READER$.read(this, SpecificData.getDecoder(in));
	}

	@Override
	protected boolean hasCustomCoders() {
		return true;
	}

	@Override
	public void customEncode(org.apache.avro.io.Encoder out) throws java.io.IOException {
		out.writeString(this.date);

		out.writeString(this.country);

		out.writeString(this.city);

		out.writeDouble(this.value);

	}

	@Override
	public void customDecode(org.apache.avro.io.ResolvingDecoder in) throws java.io.IOException {
		org.apache.avro.Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();
		if (fieldOrder == null) {
			this.date = in.readString(this.date instanceof Utf8 ? (Utf8) this.date : null);

			this.country = in.readString(this.country instanceof Utf8 ? (Utf8) this.country : null);

			this.city = in.readString(this.city instanceof Utf8 ? (Utf8) this.city : null);

			this.value = in.readDouble();

		} else {
			for (int i = 0; i < 4; i++) {
				switch (fieldOrder[i].pos()) {
				case 0:
					this.date = in.readString(this.date instanceof Utf8 ? (Utf8) this.date : null);
					break;

				case 1:
					this.country = in.readString(this.country instanceof Utf8 ? (Utf8) this.country : null);
					break;

				case 2:
					this.city = in.readString(this.city instanceof Utf8 ? (Utf8) this.city : null);
					break;

				case 3:
					this.value = in.readDouble();
					break;

				default:
					throw new java.io.IOException("Corrupt ResolvingDecoder.");
				}
			}
		}
	}

	public static void SerializeAvros(ArrayList<avro> avros, String exportPath) {

		DatumWriter<avro> datumWriter = new SpecificDatumWriter<avro>(avro.class);
		DataFileWriter<avro> dataFileWriter = new DataFileWriter<avro>(datumWriter);
		try {
			dataFileWriter.create(avros.get(0).getSchema(), new File(exportPath+"/avro.avro"));
			for (avro tempAvro : avros) {
				dataFileWriter.append(tempAvro);
			}
			dataFileWriter.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static ArrayList<String> DeserializeAvro(String avroFileString) {

		ArrayList<String> toReturn = new ArrayList<String>();

		DatumReader<avro> datumReader = new SpecificDatumReader<avro>(avro.class);
		try {
			DataFileReader<avro> dataFileReader = new DataFileReader<avro>(new File(avroFileString), datumReader);

			avro tempAvro = new avro();
			while (dataFileReader.hasNext()) {
				tempAvro = dataFileReader.next(tempAvro);
				toReturn.add(tempAvro.toString());
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		return toReturn;
	}
}
